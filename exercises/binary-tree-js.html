<html>
	<head>
		<title>binary trees</title>
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
		<style>
			body { font-family: sans-serif;}
			div { 
				margin-left:15px;
				padding:3px 0;
			}
			#htmlTree { 
				width:800px;
			}
			.tree-row { 
				list-style-type:none;
				text-align:center;
				width:100%;
				margin:0;
				padding:0;
				position:relative; /* so li's can go absolute */
				height:4em;
			}
			.tree-row>li {
				display:inline-block;
				border:1px solid black;
				height:1.5em;
				padding:.5em;
				/*-webkit-border-radius: 12px; /* Safari 3-4, iOS 1-3.2, Android ≤1.6 */
          		/*border-radius: 12px; /* Opera 10.5, IE9+, Safari 5, Chrome, Firefox 4+, iOS 4, Android 2.1+ */
          		margin-left:40px;
          	/*	position:absolute; /*left position will be dynamic in js*/*/
			}
		
			.tree-cell-inner { 
				display: inline-block;
			}
			.node-left { 
				float:left; 
				font-size:8px;
				margin: 60% 0 0 0;
			}
			.node-right { 
				float:right; 
				font-size:8px;
				margin:60% 0 0 0;
			}
			.clear { 
				clear:both;
			}
			canvas { border: 1px solid black;}
			div.line-black{
				transform-origin: 0 100%;
  				height: 1px; /* Line width  */
  				background: #000; /* Black fill */
			}
			div.line-blue{
				transform-origin: 0 100%;
  				height: 1px; /* Line width */
  				background: #00F; /* Blue fill */
			}
		</style>
	</head>
	<body>
	<!--	<h2>Binary Trees for fun and profit(???)</h2>
		<p>Tree data: <span id="rawData"></span></p> 
		<p>Depth traversal, pre-order: <span id="traverseDepthPre"></span></p>
		<p>Depth traversal, in-order: <span id="traverseDepthIn"></span></p>
		<p>Depth traversal, post-order: <span id="traverseDepthPost"></span></p>
		<p>Breadth traversal: <span id="traverseBreadth"></span></p>
		<p>HTML rendering (uses post-order depth traversal):</p>-->
		<div id="htmlTree"></div>
		<!--<div class="clear"></div>
		<p>Canvas rendering (uses depth traversal):</p>
		<canvas id="canvas" height="600" width="900"></canvas>-->

		<script type="text/javascript">
			//Tree object
			function Tree (rootNode) { 
				this.rootNode = rootNode; 
			}

			Tree.prototype.insertNode = function(node, parentNode) { 
				if (!parentNode) { 
					parentNode = this.rootNode; 
				}

				if (node.id < parentNode.id) { 
					if (!parentNode.left) {  
						parentNode.left = node; 
					}
					else{
						this.insertNode(node, parentNode.left); 
					}
				}
				else { 	
					if (!parentNode.right) { 
						parentNode.right = node; 
					}
					else{
						this.insertNode(node, parentNode.right); 
					}
				}
			}

			Tree.prototype.traverseDepth = function(startNode, visit, order) { 
				var depth=0, width=0; // cheating for ease of rendering
				function traversePreOrder(node) { 
					if (node) { 
						depth++;  
						if (visit) { 
							visit.call(this, node, depth, width); //could add depth & width to each node...
						}

						//left subtree
						if (node.left) { 
							width -= 15; 
							traversePreOrder(node.left); 
							width += 15; 
						}

						//right subtree
						if (node.right) { 
							width += 15; 
							traversePreOrder(node.right);
							width -=15;  
						}
						depth--; 			
					}
				}
				function traverseInOrder(node) { 
					if (node) { 
						depth++;  
						//left subtree
						if (node.left) { 
							width -= 15; 
							traverseInOrder(node.left); 
							width += 15; 
						}
						if (visit) { 
							visit.call(this, node, depth, width); //could add depth & width to each node...
						}
						//right subtree
						if (node.right) { 
							width += 15; 
							traverseInOrder(node.right);
							width -=15;  
						}
						depth--; 			
					}
				}
				function traversePostOrder(node) { 
					if (node) { 
						depth++;  

						//left subtree
						if (node.left) { 
							width -= 15; 
							traversePostOrder(node.left); 
							width += 15; 
						}

						//right subtree
						if (node.right) { 
							width += 15; 
							traversePostOrder(node.right);
							width -=15;  
						}
						if (visit) { 
							visit.call(this, node, depth, width); //could add depth & width to each node...
						}
						depth--; 			
					}
				}

				if (!startNode) { 
					startNode = this.rootNode; 
				}
				if (!order || order==="in") { 
					traverseInOrder(startNode);
				}
				else if (order ==="pre") { 
					traversePreOrder(startNode);
				}
				else if (order ==="post") { 
					traversePostOrder(startNode)
				}	 
			}

			Tree.prototype.traverseBreadth = function(startNode, visit) { 
				//process node, put node's children in a queue (left then right), dequeue node and recurse
				var myQueue = new queue();
				function traverseNode(node) {
					if (!node) { return; } //end of queue

					if (visit) { 
						visit.call(this,node); 
					} 
					if (node.left) { 
						myQueue(node.left); //enqueue
					} 
					if (node.right) { 
						myQueue(node.right); //enqueue
					}
					traverseNode(myQueue()); //dequeue & recurse
				}
				if (!startNode){ 
					startNode = this.rootNode; 
				}
				traverseNode(startNode); 
			}

			//TODO: 
			Tree.prototype.deleteNode = function(node) { 
				console.log("deleting node:" + node);
			}

			Tree.prototype.findNode = function(id, node) { 
				if (!node) { 
					node = this.rootNode; 
				}

				while (node){
					if (id > node.id) { 
						node = node.right;  
					}
					else if (id > node.id) { 
						node = node.left; 
					}
					else { 
						break ; //found it
					}
				}
				return node; 
			}
			//recursive - 80% slower 
			//http://jsperf.com/binary-search-tree-find-recursive-vs-non
			Tree.prototype.findNodeRecursiveButSlower = function(id, startNode) { 
				function traverseFind(id, node) { 
					if (!node) { 
						return node; //not in the tree
					}
					else if (id > node.id) { 
						return traverseFind(id, node.right);
					}
					else if (id < node.id) { 
						return traverseFind(id, node.left);
					}
					else {  
						return node; //found it 
					}
				}
				if (!startNode) { 
					startNode = this.rootNode; 
				}
				return traverseFind(id, startNode); 
			}

			
			// --- ---
			//credit to Nicholas Zakas for these
			Tree.prototype.toArray = function() { 
		        var result = [];
		        
		        this.traverseDepth(this.rootNode, function(node){
		            result.push(node.id);}, "in");
		        
		        return result;
			}


			Tree.prototype.toString = function() { 
				return this.toArray().toString(); 
			}

			Tree.prototype.size = function(startNode) { 
				var length=0; 
				this.traverseDepth(startNode, function(node) { 
					length++; 
				});
				return length;
			}
			// --- ---

			Tree.prototype.canvasRender = function(startNode) { 
				this.traverseDepth(startNode, canvasHelper.writeCanvasText);
			}

			//http://monkeyandcrow.com/blog/drawing_lines_with_css3/
			function createLine(x1,y1, x2,y2,style){
				console.log(JSON.stringify(arguments));
				var length = Math.sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));
				var angle  = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
				var transform = 'rotate('+angle+'deg)';

			    var line = $('<div>')
			        .appendTo('body')
			        .addClass(style)
			        .css({
			          'position': 'absolute',
			          'transform': transform
			        })
			        .width(length)
			        .offset({left: x1, top: y1});
			    
			  //  return line;
			}

			//targetElement is a jquery element with the html tree inside
			//this won't be the fastest code ever, but drawing lines costs money
			function connectNodes(targetElement){
				function findTopPos(ele) {  //http://stackoverflow.com/questions/1350581/how-to-get-an-elements-top-position-relataive-to-the-browsers-window
					var curtop = 0;
					var curtopscroll = 0;
					if (ele.offsetParent) {
						do {
							curtop += ele.offsetTop;
							curtopscroll += ele.offsetParent ? ele.offsetParent.scrollTop : 0;
						} while (ele = ele.offsetParent);

						return(curtop - curtopscroll);
					}
					return 0; 
				}

				$(targetElement).find("li").each(function(index,item) { 
					var $item = $(item);
					var myLeftNodeId = $item.data('left'),
						myRightNodeId = $item.data('right'); 

					if (myLeftNodeId != "") {
						var myLeftEle = document.getElementById("tree-cell-" + myLeftNodeId);
						var x1 = item.offsetLeft; //my left edge x-coord
						var x2 = myLeftEle.offsetLeft + myLeftEle.offsetWidth; //my left child's right edge x-coord
						var y1 = findTopPos(item); //my bottom y-coord
						var y2 = findTopPos(myLeftEle) //.offsetTop; //my left child's top y-coord
						console.log("connect ID: " + item.id + " to " + myLeftNodeId + " blue: " + x1 + "," + y1 + ":" + x2 +","+y2);
						createLine(x1,y1,x2,y2,"line-blue"); 
					}
					//var x1 = 
					if (myRightNodeId != "") {
						var myRightEle = document.getElementById("tree-cell-" + myRightNodeId)
						var x2 = item.offsetLeft + item.offsetWidth; //my right edge
						var x1 = myRightEle.offsetLeft; //my right child's left edge
						var y2 = findTopPos(item) + item.offsetHeight; //my bottom y-coord
						var y1 = findTopPos(myRightEle); //my right child's top y-coord
						console.log("connect ID: " + item.id + " to " + myRightNodeId + " black: " + x1 + "," + y1 + ":" + x2 +","+y2);
						createLine(x1,y1,x2,y2,"line-black"); 
					}

					
				});
			}

			Tree.prototype.htmlRender = function(startNode, targetElement) { 

				//traverse the tree, visit function (anonymous) builds the html for each node
				this.traverseDepth(startNode, function(node, depth){
						var myRow = $.data(targetElement, 'row'+ depth); //memoize the rows to avoid reselecting on each node or appending every child
						myRow = myRow ? myRow +node.htmlRender(true) : node.htmlRender(true);  // append if we already had something, otherwise insert
						$.data(targetElement, 'row'+ depth, myRow); //put back to the data				
		            }, "pre");
				
				//get the fully built rows out and append to the parent 
				var counter=1;  //depth starts at 1
				$targetElement = $(targetElement); 
				while (true) { 
					var row = $.data(targetElement, 'row' + counter) ; 
					if (!row) {
						break; 
					}
					row = "<ul class='tree-row' id='tree-row-" + counter + "'>" + row + "</ul>"; //build a ul with node li's inside
					$targetElement.append(row); //append to parent
					counter++
				}
				//draw lines!
				connectNodes($targetElement); 
			}

			// *** TreeNode object *** 
			function TreeNode(id) { 
				this.id = id;
				this.left = undefined; 
				this.right= undefined;
			}
			
			TreeNode.prototype.htmlRender = function(showChildren) { 
				function renderChildId(childId, css) {
					return ("<div class='" + css + "'>" + childId + "</div>");
				}

				var ele = "<li id='tree-cell-" + this.id 
							+ "' data-left='" + (this.left ? this.left.id : "") 
							+ "' data-right='" + (this.right ? this.right.id : "") 
							+ "'>" + this.id; 
				if (showChildren) { 
					if (this.left) { 
						ele += renderChildId(this.left.id, "node-left"); 
					}
					if (this.right) { 
						ele += renderChildId(this.right.id, "node-right"); 
					}
				}
				ele += "</li>"
				return ele; 
			}

			//boo to inline styles, but need to dynamically position
			//output of this can be used in a jquery css function call
			function getNodeCss(node) { 
				if (node.leftEdge) { 
					return {"left": node.leftEdge}
				}
				else if (node.rightEdge){ 
					return {"left": node.rightEdge}
				} 
				return undefined; 
			}

			//super slow compared to string concat http://jsperf.com/jquery-dom-create-vs-string
			TreeNode.prototype.htmlRenderjQuery = function(showChildren){  
				if (!showChildren) { showChildren = true};
				var myCss = getNodeCss(this);
				var ele = $("<li>", {
							id: "tree-cell-" + this.id, 
							text: this.id,
							"data-left" : (this.left ? this.left.id : undefined), 
							"data-right" : (this.right ? this.right.id : undefined),
							css: myCss ? myCss : ""  
						}); 
				if (this.left && showChildren) { 
					ele.append($("<div>",{ 
									text: this.left.id,
									addClass : "node-left"
								}))
				}
				if (this.right && showChildren){ 			
					ele.append($("<div>", { 
									text: this.right.id,
									addClass : "node-right"
						})); 
				}
				return ele;
			}
			Array.prototype.shuffle = function () { 
				var m = this.length, t, i;
				
				// While there remain elements to shuffle…
  				while (m) {
				    // Pick a remaining element…
				    i = Math.floor(Math.random() * m--);

				    // And swap it with the current element.
				    t = this[m];
				    this[m] = this[i];
				    this[i] = t;
  				}
			};

			//queue implementation to avoid shift operation
			function queue() { 
				var first=0, last=-1, list=[], undefined; 
				return function(value){
					//enqueue
					if (value !== undefined) { 
						return list[++last] = value; 
					}
					//empty queue
					if (first > last) { 
						return undefined;
					}
					//called with no arg - dequeue
					value = list[first];
					delete list[first]; 
					first++; 
					return value; 
				}
			}


			//*** *** *** *** *** *** *** 
			//init & run like the wind
			var maxNodes=20;
			var sourceData = [];
			//array of numbers
			for (var i=0; i<maxNodes; i++) { 
				sourceData.push(i); 
			} 
			//randomize
			sourceData.shuffle(); 

			var	rootNode = new TreeNode(sourceData[0]); 
			var	myTree = new Tree(rootNode);

			for (var i=1; i<maxNodes; i++){
				var myNode = new TreeNode(sourceData[i]); 
				myTree.insertNode(myNode);
			}
			var outputHelper = (function() { 
				return { 

					DebugOutput : function() {
						//debug-ish output
						var ele = document.getElementById("rawData"); 
						if (ele) { 
							ele.innerHTML = sourceData.toString();
						}

						var tempArr = [];
						ele = document.getElementById("traverseDepthPre");
						if (ele) {
							myTree.traverseDepth(rootNode, function(node) {tempArr.push(node.id)}, "pre");
							ele.innerHTML = tempArr.toString(); 
						}
						tempArr=[];
						ele = document.getElementById("traverseDepthIn");
						if (ele) {
							//also myTree.toArray() or myTree.toString(); 
							myTree.traverseDepth(rootNode, function(node) {tempArr.push(node.id)}, "in");
							ele.innerHTML = tempArr.toString(); 
						}
						tempArr=[];
						ele = document.getElementById("traverseDepthPost");
						if (ele) {
							myTree.traverseDepth(rootNode, function(node) {tempArr.push(node.id)}, "post");
							ele.innerHTML = tempArr.toString(); 
						}
						tempArr=[];
						ele = document.getElementById("traverseBreadth");
						if (ele) {
							myTree.traverseBreadth(rootNode, function(node) {tempArr.push(node.id)});
							ele.innerHTML = tempArr.toString(); 
						}

						ele = document.getElementById("htmlTree"); 
						if (ele) { 
							myTree.htmlRender(rootNode, ele); 
						}

						//find a random number
						var idToFind = Math.floor(Math.random() * maxNodes); 
						console.log("FINDING: " + idToFind);
						console.log(myTree.findNode(idToFind)); 
					}
				}
			})(); 
var ele = document.getElementById("htmlTree"); 
						if (ele) { 
							myTree.htmlRender(rootNode, ele); 
						}
			//console.log(myTree); 

			var canvasHelper = (function(){ 
				//init canvas
				var canvas = document.getElementById('canvas'),
				context = canvas.getContext('2d'),
				canvasWidth = parseInt(canvas.getAttribute("width")), 
				canvasHeight = parseInt(canvas.getAttribute("height")),	 
				center = canvasWidth/2, 
				xLoc = canvasWidth/2,  
				yLoc = 10;

				//public 
				return { 
					writeCanvasText: function(node, depth, width) {
						var xLoc = center + width, 
							yStep=30,
							yLoc = depth*yStep;
			
						yLoc = depth*30;
						context.fillStyle = width < 0 ? "blue" : "red";
						context.font = "14px san-serif"; 
					//	console.log("writing " +node.id+ " -- depth: " + depth + " width: " + width + " --to :" + xLoc + ":" + yLoc);
						//console.log("----------------------");
						context.fillText(node.id, xLoc, yLoc);

						if (!node.left) { yLoc -= yStep} //if we hit a stop, move back up
					}
				}
			})(); 

			$(document).ready(function() { 
				//HTML output
				//outputHelper.DebugOutput(); 
				//Canvas output
				//myTree.canvasRender(); 
			})
			

		</script>
	</body>
</html>
