<html>
	<head>
		<title>Knockout Regex Tester</title>
		<script src="http://ajax.aspnetcdn.com/ajax/knockout/knockout-2.1.0.js"></script> 
		
		<style>
			body { font-family: helvetica, arial; font-size: 1em; } 
			#pattern, textarea { display:block; font-family: inherit; font-size: inherit; width: 300px; margin-bottom:25px;} 
			textarea { height: 100px }
			label { display:block; font-weight:bold;}
			.options label { display:inline; font-size:.75em; margin-right:5px;}
			p { font-weight:bold; margin-bottom:0px;}
			.highlight { color:#060; background-color:#C5F7C5; } 
			.box { background-color:#EEE; min-height:2em; padding:10px; display:inline-block; margin: auto; margin-bottom:25px; border: solid 1px #CCC; }
			.output-box { background-color:#fff;}
			.regex { margin-top:0px; font-weight:normal; text-decoration:none} 
			#error-message { color:#F00 } 
		</style> 
	</head>
	<body> 
		<div class="box">
			<label for="pattern">Pattern</label>
			<input id="pattern" data-bind="value:regexPattern, valueUpdate:'afterkeydown'" name="regexPattern" placeholder="Enter your regex here.">
			<div class="options">
				<p>Options: <span data-bind="text:regexOptions"></span></p>
				<input type="checkbox" id="opt-global" data-bind="checked:optionGlobal">
				<label for="opt-global">g</label>
				<input type="checkbox" id="opt-case" data-bind="checked:optionCase">
				<label for="opt-case">i</label>
				<input type="checkbox" id="opt-lines" data-bind="checked:optionLines">
				<label for="opt-case">m</label>
			</div>
			</br>

			<label for="stringToTest">String To Test</label>
			<textarea id="stringToTest" data-bind="value:stringToTest, valueUpdate:'afterkeydown'" name="stringToTest" placeholder="Enter your test string here."></textarea>

			</br>
			<!--output--> 
			<div class="box output-box">
				<div data-bind="highlightedText: { text:stringToTest, matches: regexExecResult(), css: 'highlight'}"></div>
				<p>Matches</p>
				<span data-bind="text:lastMatchedString"></span>
				<p data-bind="visible:hasCaptures()">Capture groups</p>
				<ol data-bind="foreach: regexExecResult">
					<li><span data-bind="text:matchedText"></span> + <span data-bind="text:index"></span> </li>
				</ol> 
				<p data-bind="html:errorMsg" id="error-message"></p>
			</div>
		</div>
		<script type="text/javascript">
			function ViewModel() {
				var self = this; 
				//input fields
				self.regexPattern = ko.observable(".at"); 
				self.stringToTest = ko.observable("catbatcat"); 
				
				//options
				self.optionGlobal = ko.observable(true);
				self.optionCase = ko.observable(false); 
				self.optionLines = ko.observable(false);

				//options helper
				self.regexOptions = ko.computed(function () { 
					return (self.optionGlobal() ? "g" : "") + 
							(self.optionCase() ? "i" : "") + 
							(self.optionLines() ? "m" : ""); 
				}); 

				self.errorMsg = ko.observable(); 
				self.lastMatchedString = ko.observable(""); 

				self.okToRunRegex = function() { 
					if (!self.regexPattern() || !self.stringToTest()) {
						return false; 
					}
					return true; 
				}

				//output vars
				self.regexMatches = ko.observableArray(); 
				self.regexExecResult = ko.observableArray(); 
				self.regexReplace = ko.observable(""); 

				self.processRegex = ko.computed(function() { 
					self.lastMatchedString("");

					if (!self.okToRunRegex()) {
						return false; 
					}
					try { 
						var pattern = new RegExp(self.regexPattern().trim(), self.regexOptions());
						//var match = self.stringToTest().match(pattern);
						//var execMatch = pattern.exec(self.stringToTest());
						//self.stringToTest().replace(pattern);

						self.errorMsg(""); 

						//if (match && match.length > 0 ){
						//	self.regexMatches(match); 
						//}

						var execMatch; 
						self.regexExecResult([]); 
						while (execMatch = pattern.exec(self.stringToTest())){
							self.regexExecResult.push({matchedText: execMatch[0], index: execMatch.index});
						}
						//console.log("--" + self.regexExecResult());
						//if (execMatch && execMatch.length > 0){
						//	console.log("first: " + execMatch); 
						//	self.regexExecResult.push(execMatch);
							//self.regexExecResult(execMatch);
						//	self.lastMatchedString(execMatch[0]);
							//return execMatch.length > 1 ? execMatch.slice(1,execMatch.length) : [];
						//	if (execMatch.length > 1){
						//		while(execMatch = pattern.exec(self.stringToTest())) {
									//var myMatch = {matchedText: execMatch[1], index: execMatch.index};
    					//			console.log("IN:" + execMatch); 
    								//console.log(myMatch); 
    								//self.regexExecResult(execMatch.slice(1,execMatch.length)); 
    					//			self.regexExecResult.push(execMatch);  
						//		}
						//	}
						//}
					}
					catch(err){ 
						self.errorMsg(err.message); 
					}
				});
					
			    self.hasCaptures = ko.computed(function() {
        			return self.regexExecResult() && self.regexExecResult().length> 0; 
	            }); 
			}
			ko.applyBindings(new ViewModel()); 
			ko.bindingHandlers.highlightedText= { 
				//init: function(element, valueAccessor){ console.log("IN INIT " + new Date()); },
				update: function(element, valueAccessor) {
					//console.log("IN update");
			        var options = valueAccessor();
			        var value = ko.utils.unwrapObservable(options.text);
			        var matches = ko.utils.unwrapObservable(options.matches);
			        var css = ko.utils.unwrapObservable(options.css);
			        if (options.sanitize) {
			            value = $('<div/>').text(value).html(); //could do this or something similar to escape HTML before replacement, if there is a risk of HTML injection in this value
			        }
			        
					for (i=matches.length-1; i>-1; i--){
						var replacement = '<span class="' + css + '">' + matches[i].matchedText + '</span>';
						//var xyz = value.substr(0,index) + replacement + this.substr(index + matches[i].matchedText.length);
						//element.innerHTML = value.replace(new RegExp(matches[i].matchedText, 'g'), replacement);
						value = value.replaceAt(matches[i].index, replacement, matches[i].length);
						//console.log(value.substring(matches[i].index));	
						console.log("*" + value.replaceAt(matches[i].index, replacement));
					}
					element.innerHTML = value; 

			        
			    }
			}
			String.prototype.replaceAt=function(index, substring, length){
				return this.substr(0,index) + substring + this.substr(index + length);
				//return this.substr(0,index) + substring + this.substr(index + substring.length);
			}

		//	ko.bindingHandlers.highlightedText= { 
		//		init: function(element, valueAccessor){ console.log("IN INIT " + new Date()); },
		//		update: function(element, valueAccessor) {
		//			console.log("IN update");
		//	        
		//	    }
		//	}
			
		</script> 
	</body>
</html>